---
status: PROVEN
layer: 0
key_result: "Sum=B, Function=L, Product=D — α⁻¹=137 as mode count"
depends_on:
  - ../axioms.md
  - ../notation.md
used_by:
  - ../proofs/irreducibility-proof.md
  - ../proofs/irreducibility-categorical.md
  - ../proofs/why-exactly-three.md
  - ../structural/factorization-calculus.md
  - ../machine/integer-factorization.md
---

# The BLD Calculus: A Minimal Type System

## Summary

**Minimal typed lambda calculus with exactly three constructors:**

1. Sum (+) = B, Function (→) = L, Product (Πₙ) = D — [Syntax](#2-syntax)
2. Type safety proven: Progress + Preservation theorems — [Metatheory](#5-metatheory)
3. Three sublanguages: LD (no B), BD (no L), BL (no D) — for irreducibility proofs — [Sublanguages](#6-sublanguages)
4. LD-calculus has cardinality 1 for all types → cannot encode Bool — [Cardinality Lemmas](#7-cardinality-lemmas)
5. Traverser type τ_trav = 1 is unique (the only type with cardinality 1) — [Theorem 8.7](#8-connection-to-bld-primitives)
6. α⁻¹ = 137 as mode count: μ(Π₄(Π₂₀1)) + μ(Σ₅₆1) + μ(1) = 80 + 56 + 1 — [Proposition 8.5](#8-connection-to-bld-primitives)

| Type Constructor | BLD | Elimination | Traversal |
|-----------------|-----|-------------|-----------|
| Sum (+) | B | case | which partition? |
| Function (→) | L | apply | follow reference |
| Product (Πₙ) | D | project | access i-th element |

---

## Abstract

We present the BLD calculus, a typed lambda calculus with exactly three type constructors: Sum (+) for Boundary, Function (→) for Link, and n-fold Product (Πₙ) for Dimension. We prove the calculus is type-safe (Progress and Preservation theorems) and define three sublanguages—LD-calculus, BD-calculus, and BL-calculus—each missing one constructor. These sublanguages are used in the irreducibility proofs to show that no constructor can be expressed using the other two. The BLD calculus serves as the formal foundation for BLD theory, providing precise semantics for the three structural primitives.

## 1. Introduction

The BLD calculus formalizes the three structural primitives of BLD theory within the framework of type theory. By providing explicit syntax, typing rules, and operational semantics, we enable rigorous proofs about the properties of B, L, and D.

The calculus is deliberately minimal. We include only the three constructors corresponding to the BLD primitives, plus a unit type as a base case. This minimality is essential for the irreducibility proofs: by showing that sublanguages missing one constructor cannot express certain types, we prove that all three constructors are necessary.

**Outline.** Section 2 defines the syntax. Section 3 presents the typing rules. Section 4 gives the operational semantics. Section 5 proves the metatheory (type safety). Section 6 defines the sublanguages. Section 7 establishes cardinality lemmas used in irreducibility proofs. Section 8 connects the calculus to BLD primitives.

## 2. Syntax

### 2.1 Types

**Definition 2.1** (Types). The types of the BLD calculus are generated by the grammar:

```
τ ::= 1              -- Unit type (base case)
    | τ₁ + τ₂        -- Sum type (Boundary)
    | τ₁ → τ₂        -- Function type (Link)
    | Πₙτ            -- n-fold product (Dimension), where n ∈ ℕ
```

*Remark 2.2.* We adopt the conventions:
- Π₀τ ≡ 1 (empty product is unit)
- Π₁τ ≡ τ (singleton product is the type itself)
- Πₙτ for n ≥ 2 represents "n copies of τ" (an n-tuple)

### 2.2 Terms

**Definition 2.3** (Terms). The terms of the BLD calculus are:

```
e ::= ()                                              -- Unit value
    | x                                               -- Variable
    | inl(e)                                          -- Left injection (B)
    | inr(e)                                          -- Right injection (B)
    | case e of {inl(x) ⇒ e₁; inr(y) ⇒ e₂}           -- Case analysis (B)
    | λx:τ.e                                          -- Abstraction (L)
    | e₁ e₂                                           -- Application (L)
    | ⟨e₁, e₂, ..., eₙ⟩                               -- n-tuple (D)
    | e.i                                             -- Projection, i ∈ {1,...,n} (D)
```

### 2.3 Values

**Definition 2.4** (Values). Values are fully-evaluated terms:

```
v ::= ()                        -- Unit value
    | inl(v)                    -- Left injection of value
    | inr(v)                    -- Right injection of value
    | λx:τ.e                    -- Function (body may not be reduced)
    | ⟨v₁, v₂, ..., vₙ⟩         -- Tuple of values
```

## 3. Typing Rules

**Definition 3.1** (Typing Context). A typing context Γ is a finite sequence of variable-type bindings x₁:τ₁, ..., xₙ:τₙ where all variables are distinct.

### 3.1 Structural Rules

**Rule 3.2** (Variable).
```
         x:τ ∈ Γ
    ─────────────── (Var)
       Γ ⊢ x : τ
```

**Rule 3.3** (Unit).
```
    ─────────────── (Unit)
      Γ ⊢ () : 1
```

### 3.2 Sum Type Rules (Boundary)

**Rule 3.4** (Left Injection).
```
        Γ ⊢ e : τ₁
    ─────────────────────── (Inl)
     Γ ⊢ inl(e) : τ₁ + τ₂
```

**Rule 3.5** (Right Injection).
```
        Γ ⊢ e : τ₂
    ─────────────────────── (Inr)
     Γ ⊢ inr(e) : τ₁ + τ₂
```

**Rule 3.6** (Case Analysis).
```
    Γ ⊢ e : τ₁ + τ₂    Γ,x:τ₁ ⊢ e₁ : τ    Γ,y:τ₂ ⊢ e₂ : τ
    ─────────────────────────────────────────────────────── (Case)
           Γ ⊢ case e of {inl(x) ⇒ e₁; inr(y) ⇒ e₂} : τ
```

### 3.3 Function Type Rules (Link)

**Rule 3.7** (Abstraction).
```
       Γ, x:τ₁ ⊢ e : τ₂
    ─────────────────────── (Abs)
      Γ ⊢ λx:τ₁.e : τ₁ → τ₂
```

**Rule 3.8** (Application).
```
     Γ ⊢ e₁ : τ₁ → τ₂    Γ ⊢ e₂ : τ₁
    ─────────────────────────────────── (App)
              Γ ⊢ e₁ e₂ : τ₂
```

### 3.4 Product Type Rules (Dimension)

**Rule 3.9** (Tuple).
```
     Γ ⊢ e₁ : τ    Γ ⊢ e₂ : τ    ...    Γ ⊢ eₙ : τ
    ─────────────────────────────────────────────────── (Tuple)
              Γ ⊢ ⟨e₁, e₂, ..., eₙ⟩ : Πₙτ
```

**Rule 3.10** (Projection).
```
        Γ ⊢ e : Πₙτ    i ∈ {1, ..., n}
    ────────────────────────────────────── (Proj)
                 Γ ⊢ e.i : τ
```

## 4. Operational Semantics

We define a small-step call-by-value reduction relation.

### 4.1 Computation Rules

**Rule 4.1** (β-Case-Left).
```
    case inl(v) of {inl(x) ⇒ e₁; inr(y) ⇒ e₂}  ⟶  e₁[v/x]
```

**Rule 4.2** (β-Case-Right).
```
    case inr(v) of {inl(x) ⇒ e₁; inr(y) ⇒ e₂}  ⟶  e₂[v/y]
```

**Rule 4.3** (β-Application).
```
    (λx:τ.e) v  ⟶  e[v/x]
```

**Rule 4.4** (β-Projection).
```
    ⟨v₁, ..., vₙ⟩.i  ⟶  vᵢ
```

### 4.2 Congruence Rules

**Rule 4.5** (Congruence for Injections).
```
         e ⟶ e'                         e ⟶ e'
    ─────────────────── (Cong-Inl)    ─────────────────── (Cong-Inr)
     inl(e) ⟶ inl(e')                  inr(e) ⟶ inr(e')
```

**Rule 4.6** (Congruence for Case).
```
                            e ⟶ e'
    ──────────────────────────────────────────────────────────── (Cong-Case)
     case e of {...} ⟶ case e' of {...}
```

**Rule 4.7** (Congruence for Application).
```
      e₁ ⟶ e₁'                    e₂ ⟶ e₂'
    ────────────── (Cong-App-L)  ────────────── (Cong-App-R)
     e₁ e₂ ⟶ e₁' e₂              v e₂ ⟶ v e₂'
```

**Rule 4.8** (Congruence for Tuples and Projections).
```
             eᵢ ⟶ eᵢ'                              e ⟶ e'
    ───────────────────────────────────────    ──────────── (Cong-Proj)
     ⟨v₁,...,eᵢ,...⟩ ⟶ ⟨v₁,...,eᵢ',...⟩         e.i ⟶ e'.i
```

## 5. Metatheory

### 5.1 Canonical Forms

**Lemma 5.1** (Canonical Forms). If ⊢ v : τ and v is a value, then:

1. If τ = 1, then v = ()
2. If τ = τ₁ + τ₂, then v = inl(v') with ⊢ v' : τ₁, or v = inr(v') with ⊢ v' : τ₂
3. If τ = τ₁ → τ₂, then v = λx:τ₁.e for some e with x:τ₁ ⊢ e : τ₂
4. If τ = Πₙσ, then v = ⟨v₁, ..., vₙ⟩ with ⊢ vᵢ : σ for all i

*Proof.* By induction on the typing derivation, using the definition of values. Each type constructor has a unique introduction form. ∎

### 5.2 Progress

**Theorem 5.2** (Progress). If ⊢ e : τ, then either:
- e is a value, or
- There exists e' such that e ⟶ e'

*Proof.* By induction on the typing derivation. Each elimination form (case, application, projection) reduces when its principal argument is a value of the appropriate form, which is guaranteed by the Canonical Forms Lemma. ∎

### 5.3 Preservation

**Lemma 5.3** (Substitution). If Γ, x:σ ⊢ e : τ and Γ ⊢ v : σ, then Γ ⊢ e[v/x] : τ.

*Proof.* By induction on the typing derivation of e. ∎

**Theorem 5.4** (Preservation). If Γ ⊢ e : τ and e ⟶ e', then Γ ⊢ e' : τ.

*Proof.* By induction on the reduction derivation. The β-rules use the Substitution Lemma. ∎

### 5.4 Type Safety

**Corollary 5.5** (Type Safety). Well-typed terms do not get stuck. That is, if ⊢ e : τ, then either e is a value or e can take a step.

*Proof.* Immediate from Progress (Theorem 5.2). ∎

## 6. Sublanguages

**Definition 6.1** (LD-Calculus). The LD-calculus is the fragment with types:
```
τ ::= 1 | τ → τ | Πₙτ
```
(no sum types)

**Definition 6.2** (BD-Calculus). The BD-calculus is the fragment with types:
```
τ ::= 1 | τ + τ | Πₙτ
```
(no function types)

**Definition 6.3** (BL-Calculus). The BL-calculus is the fragment with types:
```
τ ::= 1 | τ + τ | τ → τ
```
(no Πₙ for n > 1; Π₁τ ≅ τ is the identity)

**Definition 6.4** (Inhabitance). A type τ is *inhabited* if there exists a closed value v with ⊢ v : τ.

**Definition 6.5** (Cardinality). The *cardinality* |τ| of an inhabited type is the number of distinct closed values of that type (possibly infinite).

## 7. Cardinality Lemmas

*Remark 7.1.* These lemmas support the irreducibility proofs in [irreducibility-categorical.md](../proofs/irreducibility-categorical.md).

### 7.1 Full BLD Calculus

**Proposition 7.2** (BLD Cardinality). In the full BLD calculus:

| Type | Cardinality |
|------|-------------|
| 1 | 1 |
| τ₁ + τ₂ | \|τ₁\| + \|τ₂\| |
| τ₁ → τ₂ | \|τ₂\|^{\|τ₁\|} |
| Πₙτ | \|τ\|^n |

### 7.2 LD-Calculus Cardinality

**Lemma 7.3** (LD Cardinality). In the LD-calculus, every closed inhabited type has cardinality exactly 1.

*Proof.* By structural induction on types in LD-calculus.

*Base case:* The type 1 has exactly one closed value: ().

*Inductive case for Πₙτ:* Assume |τ| = 1 by the induction hypothesis. Then |Πₙτ| = |τ|^n = 1^n = 1. The unique value is ⟨v, v, ..., v⟩ where v is the unique value of type τ.

*Inductive case for τ₁ → τ₂:* Assume |τ₁| = 1 and |τ₂| = 1 by the induction hypothesis. Then |τ₁ → τ₂| = |τ₂|^{|τ₁|} = 1^1 = 1. The unique value is λx:τ₁.v₂ where v₂ is the unique value of type τ₂. ∎

**Corollary 7.4.** The LD-calculus cannot encode Bool = 1 + 1, which has cardinality 2.

### 7.3 BD-Calculus Properties

**Lemma 7.5** (BD is Data-Only). In the BD-calculus, every closed term reduces to a canonical form that is fully determined by its type and does not depend on runtime inputs.

*Remark 7.6.* The BD-calculus can represent function *graphs* (as lookup tables) but not functions as first-class values that can be applied.

### 7.4 BL-Calculus Properties

**Lemma 7.7** (BL is Fixed-Arity). In the BL-calculus, every type has fixed finite structure independent of any natural number parameter.

*Remark 7.8.* The BL-calculus cannot uniformly express the family {Πₙτ : n ∈ ℕ}.

## 8. Connection to BLD Primitives

**Proposition 8.1** (BLD Correspondence). The type constructors correspond to BLD primitives:

| Type Constructor | BLD Primitive | Traversal Operation |
|-----------------|---------------|---------------------|
| Sum (+) | Boundary (B) | Case analysis (which partition?) |
| Function (→) | Link (L) | Application (follow reference) |
| Product (Πₙ) | Dimension (D) | Projection (access i-th element) |

*Remark 8.2.* The elimination forms correspond exactly to traverser capabilities:
- **case**: Discriminate based on tag (B capability)
- **apply**: Dereference a function at a point (L capability)
- **project**: Index into a tuple (D capability)

**Definition 8.3** (Structural Mode Count). For a type τ in the BLD calculus, the *structural mode count* μ(τ) is:

```
μ(1) = 1                           (unit type: 1 mode)
μ(τ₁ + τ₂) = μ(τ₁) + μ(τ₂)        (sum: modes add)
μ(τ₁ → τ₂) = μ(τ₂)^μ(τ₁)          (function: exponential)
μ(Πₙτ) = n × μ(τ)                  (product: modes multiply by repetition)
```

*Remark 8.4.* This differs from cardinality (Proposition 7.2) in the product case: cardinality counts inhabitants (|Πₙτ| = |τ|^n), while mode count counts structural dimensions (μ(Πₙτ) = n × μ(τ)). Mode count corresponds to vector space dimension under the BLD-representation correspondence.

**Proposition 8.5** (α⁻¹ as Mode Count). The fine structure constant integer part is the mode count of electromagnetic structure:

```
α⁻¹ = μ(τ_geom) + μ(τ_bound) + μ(τ_trav)
    = μ(Π₄(Π₂₀1)) + μ(1 + ... + 1)₅₆ + μ(1)
    = (4 × 20) + 56 + 1
    = 137
```

where:
- τ_geom = Π₄(Π₂₀1): 4-dimensional space with 20 curvature modes each
- τ_bound = Σ₅₆1: 56-way sum (boundary partitions)
- τ_trav = 1: unit type (traverser existence)

*Remark 8.6.* The traverser contributes μ(1) = 1 because the unit type is the terminal object in the category of types. It has exactly one inhabitant: (). This is the type-theoretic formalization of "the traverser exists but carries no additional information."

**Theorem 8.7** (Traverser Type Uniqueness). The type τ_trav = 1 is the *unique* BLD type satisfying the traverser constraints.

*Proof.* The traverser type must satisfy:
1. **Cardinality 1** — no internal structure (traverser exists, nothing more)
2. **Inhabited** — traverser must exist for measurement
3. **BLD-expressible** — constructible from {1, +, →, Πₙ}

We show 1 is the only type satisfying all three:

- **Sum types** τ₁ + τ₂: Have |τ₁ + τ₂| = |τ₁| + |τ₂|. For inhabited types, |τ₁| ≥ 1 and |τ₂| ≥ 1, so |τ₁ + τ₂| ≥ 2. Violates (1).

- **Function types** τ₁ → τ₂: Have |τ₁ → τ₂| = |τ₂|^{|τ₁|}. If |τ₁| ≥ 2 and |τ₂| ≥ 1, then |τ₁ → τ₂| ≥ 1. But for |τ₁ → τ₂| = 1, we need |τ₂| = 1 (since x^1 = x). This recursively requires τ₂ = 1. And if τ₁ = 1, then 1 → 1 has cardinality 1^1 = 1, but this is isomorphic to 1 (the constant function). So function types either have cardinality > 1 or reduce to 1.

- **Product types** Πₙτ: Have |Πₙτ| = |τ|ⁿ. For n ≥ 2 and |τ| ≥ 1, we get |Πₙτ| ≥ 1. For |Πₙτ| = 1, we need |τ| = 1, so τ = 1. Then Πₙ1 ≅ 1 (n-tuple of units is just unit). Reduces to 1.

- **Unit type** 1: Has |1| = 1, is inhabited by (), and is BLD-expressible. Satisfies all three. ✓

Therefore τ_trav = 1 is unique. ∎

## 9. Related Work

The BLD calculus is a variant of simply-typed lambda calculus with sums and products. The key design choices are:

1. **n-fold products** rather than binary products, to capture the "repetition" aspect of Dimension
2. **Homogeneous products** (all components same type), reflecting the structural role of D
3. **Explicit sublanguages** to support irreducibility proofs

The correspondence between type constructors and logical connectives is the Curry-Howard isomorphism [Howard, 1980]. Our contribution is showing that exactly three constructors (plus a base type) suffice for structural completeness.

The metatheory follows standard techniques from [Pierce, 2002] and [Harper, 2016].

## 10. Conclusion

The BLD calculus provides a minimal, well-founded type system with exactly three constructors corresponding to the BLD primitives. The type safety results (Progress and Preservation) ensure the system is consistent. The sublanguages and cardinality lemmas provide the formal tools needed for the irreducibility proofs.

## References

[Girard et al., 1989] J.-Y. Girard, Y. Lafont, and P. Taylor. *Proofs and Types*. Cambridge University Press, 1989.

[Harper, 2016] R. Harper. *Practical Foundations for Programming Languages*. Cambridge University Press, 2nd ed., 2016.

[Howard, 1980] W. A. Howard. "The formulae-as-types notion of construction." In *To H.B. Curry: Essays on Combinatory Logic, Lambda Calculus and Formalism*, Academic Press, 1980, pp. 479-490.

[Martin-Löf, 1984] P. Martin-Löf. *Intuitionistic Type Theory*. Bibliopolis, 1984.

[Pierce, 2002] B. C. Pierce. *Types and Programming Languages*. MIT Press, 2002.

[Wadler, 1989] P. Wadler. "Theorems for Free!" In *Proceedings of FPCA*, ACM, 1989, pp. 347-359.
