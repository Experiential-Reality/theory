"""Hypercharge normalization and u(4) gauge algebra structure.

Tests 46-52 from the equation of motion suite.
Gauge algebra closure, u(4) identification, centralizer structure,
SM hypercharge matching.
"""

import math

import numpy as np
import numpy.linalg as la

import tools.bld

from helpers import assert_all_pass


TR = tools.bld.TestResult
SO8 = tools.bld.SO8


# ---------------------------------------------------------------------------
# Test 46: Gauge factors su(3) and su(2) do not commute
# ---------------------------------------------------------------------------


def test_gauge_factors_noncommuting(so8: SO8) -> None:
    """[su(3), su(2)] ≠ 0: the gauge factors are not a direct product.

    Prove: max ||[su3_a, su2_i]|| > 0 for some (a, i).
    Prove: [su3, su2_0] are in the gauge span (all in-gauge).
    Prove: [su3, su2_1] leak into the complement (not all in-gauge).
    Verify: su(3) alone closes (8-dim).
    Verify: su(2) alone closes (3-dim).
    Verify: [E01, su(3)] = 0 (u(1) commutes with su(3)).
    """
    results: list[TR] = []

    # su(3) closure
    Q_su3, _ = la.qr(so8.su3.T, mode="reduced")
    proj_su3 = Q_su3 @ Q_su3.T
    max_su3_leak = 0.0
    for a in range(8):
        for b in range(a + 1, 8):
            bracket = tools.bld.lie_bracket(so8.su3[a], so8.su3[b], so8.f)
            leak = float(la.norm(bracket - proj_su3 @ bracket))
            if leak > max_su3_leak:
                max_su3_leak = leak
    results.append(TR(
        f"su3_closure_leak={max_su3_leak:.2e}",
        max_su3_leak < 1e-12,
    ))

    # su(2) closure
    Q_su2, _ = la.qr(so8.su2.T, mode="reduced")
    proj_su2 = Q_su2 @ Q_su2.T
    max_su2_leak = 0.0
    for i in range(3):
        for j in range(i + 1, 3):
            bracket = tools.bld.lie_bracket(so8.su2[i], so8.su2[j], so8.f)
            leak = float(la.norm(bracket - proj_su2 @ bracket))
            if leak > max_su2_leak:
                max_su2_leak = leak
    results.append(TR(
        f"su2_closure_leak={max_su2_leak:.2e}",
        max_su2_leak < 1e-12,
    ))

    # [E01, su(3)] = 0
    max_u1_su3 = 0.0
    for a in range(8):
        bracket = tools.bld.lie_bracket(so8.u1, so8.su3[a], so8.f)
        n = float(la.norm(bracket))
        if n > max_u1_su3:
            max_u1_su3 = n
    results.append(TR(
        f"[u1,su3]={max_u1_su3:.2e}=0",
        max_u1_su3 < 1e-14,
    ))

    # [su(3), su(2)] ≠ 0
    Q_gauge, _ = la.qr(so8.gauge.T, mode="reduced")
    proj_gauge = Q_gauge @ Q_gauge.T

    max_cross = 0.0
    max_comp_leak = 0.0
    for a in range(8):
        for i in range(3):
            bracket = tools.bld.lie_bracket(so8.su3[a], so8.su2[i], so8.f)
            n = float(la.norm(bracket))
            if n > max_cross:
                max_cross = n
            comp = float(la.norm(bracket - proj_gauge @ bracket))
            if comp > max_comp_leak:
                max_comp_leak = comp

    results.append(TR(
        f"[su3,su2]_max={max_cross:.4f}>0",
        max_cross > 0.1,
    ))

    # Some cross-brackets leak into complement
    results.append(TR(
        f"cross_complement_leak={max_comp_leak:.4f}>0",
        max_comp_leak > 0.1,
    ))

    assert_all_pass(results)


# ---------------------------------------------------------------------------
# Test 47: The 12 gauge generators generate u(4) = su(4) ⊕ u(1)
# ---------------------------------------------------------------------------


def test_gauge_generates_u4(so8: SO8) -> None:
    """The 12 nominal gauge generators generate a 16-dim subalgebra u(4).

    Prove: algebra generated by su(3) ∪ su(2) ∪ u(1) has dim 16.
    Prove: the 16-dim algebra closes under Lie bracket.
    Prove: Killing form has exactly 1 zero eigenvalue (1-dim center).
    Prove: semisimple part [g,g] has dim 15 = dim su(4).
    Verify: gauge_generated_dim() = 16.
    Disprove: the 12 generators alone do NOT close (max bracket residual > 0).
    """
    results: list[TR] = []

    # Generate the full algebra by iterated brackets
    gens = list(so8.gauge)
    span = np.array(gens, dtype=float)

    for _ in range(10):
        n_gens = len(gens)
        new_gens: list[np.ndarray] = []
        for a in range(n_gens):
            for b in range(a + 1, n_gens):
                bracket = tools.bld.lie_bracket(gens[a], gens[b], so8.f)
                if la.norm(bracket) < 1e-14:
                    continue
                Q, _ = la.qr(span.T, mode="reduced")
                proj = Q @ Q.T @ bracket
                if la.norm(bracket - proj) > 1e-10:
                    new_gens.append(bracket / la.norm(bracket))
                    span = np.vstack([span, bracket])
        if not new_gens:
            break
        gens.extend(new_gens)

    gen_dim = int(la.matrix_rank(span, tol=1e-10))
    results.append(TR(f"generated_dim={gen_dim}=16", gen_dim == 16))

    # Matches bld constant
    results.append(TR(
        f"gauge_generated_dim={tools.bld.gauge_generated_dim()}=16",
        tools.bld.gauge_generated_dim() == 16,
    ))

    # Orthonormalize the 16-dim basis
    Q16, _ = la.qr(span.T, mode="reduced")
    Q16 = Q16[:, :16]

    # Verify closure
    max_closure_res = 0.0
    for a in range(16):
        for b in range(a + 1, 16):
            bracket = tools.bld.lie_bracket(Q16[:, a], Q16[:, b], so8.f)
            proj = Q16 @ Q16.T @ bracket
            res = float(la.norm(bracket - proj))
            if res > max_closure_res:
                max_closure_res = res
    results.append(TR(
        f"u4_closure_residual={max_closure_res:.2e}",
        max_closure_res < 1e-12,
    ))

    # Killing form of the 16-dim algebra
    f16 = np.zeros((16, 16, 16))
    for a in range(16):
        for b in range(16):
            bracket = tools.bld.lie_bracket(Q16[:, a], Q16[:, b], so8.f)
            f16[a, b, :] = Q16.T @ bracket

    kf16 = np.zeros((16, 16))
    for a in range(16):
        for b in range(16):
            for c in range(16):
                for d in range(16):
                    kf16[a, b] += f16[a, c, d] * f16[b, d, c]

    kf16_eigs = np.sort(la.eigvalsh(kf16))
    n_zero = int(np.sum(np.abs(kf16_eigs) < 0.1))
    results.append(TR(f"kf16_zero_eigs={n_zero}=1", n_zero == 1))

    # The 15 nonzero eigenvalues should all be equal (simple algebra)
    nonzero_eigs = kf16_eigs[np.abs(kf16_eigs) > 0.1]
    if len(nonzero_eigs) == 15:
        spread = float(np.std(nonzero_eigs) / abs(np.mean(nonzero_eigs)))
        results.append(TR(
            f"su4_eigs_uniform_spread={spread:.2e}",
            spread < 1e-10,
        ))

    # Semisimple part dimension = 15
    results.append(TR(
        f"semisimple_dim={16 - n_zero}=15",
        16 - n_zero == 15,
    ))

    # Disprove: the 12 generators alone do NOT close
    max_12_res = 0.0
    for a in range(12):
        for b in range(a + 1, 12):
            bracket = tools.bld.lie_bracket(so8.gauge[a], so8.gauge[b], so8.f)
            proj12 = Q_gauge_proj(so8.gauge) @ bracket
            res = float(la.norm(bracket - proj12))
            if res > max_12_res:
                max_12_res = res
    results.append(TR(
        f"12_gens_NOT_closed_res={max_12_res:.4f}>0",
        max_12_res > 0.1,
    ))

    assert_all_pass(results)


def Q_gauge_proj(gauge: np.ndarray) -> np.ndarray:
    """Projection matrix onto the gauge subspace."""
    Q, _ = la.qr(gauge.T, mode="reduced")
    return Q @ Q.T


# ---------------------------------------------------------------------------
# Test 48: Centralizer of su(3) is 2-dimensional
# ---------------------------------------------------------------------------


def test_centralizer_su3(so8: SO8) -> None:
    """The centralizer of su(3) in so(8) is 2-dim: span{E₀₁, J}.

    Prove: centralizer dimension = 2.
    Prove: E₀₁ is in the centralizer ([E01, su3] = 0).
    Prove: J = -(1/√3)(E₂₄ + E₃₇ + E₅₆) is in the centralizer.
    Prove: J components correspond to Fano triples through e₁.
    Verify: J² = -(1/3)I on {e₂,...,e₇}, J²=0 on {e₀,e₁}.
    """
    results: list[TR] = []
    dim = 28

    # Build the linear system [X, T_a] = 0 for all su(3) generators
    rows: list[np.ndarray] = []
    for a in range(8):
        for m in range(dim):
            row = np.zeros(dim)
            for k in range(dim):
                for j in range(dim):
                    row[k] += so8.su3[a, j] * so8.f[k, j, m]
            rows.append(row)

    A = np.array(rows)
    rank_A = int(la.matrix_rank(A, tol=1e-10))
    cent_dim = dim - rank_A
    results.append(TR(f"centralizer_su3_dim={cent_dim}=2", cent_dim == 2))

    # E01 commutes with su(3)
    max_comm = 0.0
    for a in range(8):
        bracket = tools.bld.lie_bracket(so8.u1, so8.su3[a], so8.f)
        n = float(la.norm(bracket))
        if n > max_comm:
            max_comm = n
    results.append(TR(f"E01_in_centralizer={max_comm:.2e}", max_comm < 1e-14))

    # J commutes with su(3)
    J = tools.bld.complex_structure_j()
    max_comm_J = 0.0
    for a in range(8):
        bracket = tools.bld.lie_bracket(J, so8.su3[a], so8.f)
        n = float(la.norm(bracket))
        if n > max_comm_J:
            max_comm_J = n
    results.append(TR(f"J_in_centralizer={max_comm_J:.2e}", max_comm_J < 1e-14))

    # J components match Fano triples through e₁
    # FANO_TRIPLES containing 1: (1,2,4), (5,6,1), (7,1,3)
    # Extract the OTHER two elements from each triple containing 1
    fano_through_e1: list[tuple[int, int]] = []
    for triple in tools.bld.FANO_TRIPLES:
        if 1 in triple:
            others = sorted(x for x in triple if x != 1)
            fano_through_e1.append((others[0], others[1]))
    J_pairs = []
    for idx in range(dim):
        if abs(J[idx]) > 1e-10:
            ii, jj = 0, 0
            k = 0
            for i in range(8):
                for j in range(i + 1, 8):
                    if k == idx:
                        ii, jj = i, j
                    k += 1
            J_pairs.append((ii, jj))

    results.append(TR(
        f"J_pairs={J_pairs}=fano_e1={fano_through_e1}",
        set(J_pairs) == set(fano_through_e1),
    ))

    # J² properties: -(1/3)I on {e2,...,e7}, 0 on {e0,e1}
    J_mat = tools.bld.coeff_to_matrix(J, so8.basis)
    J_sq = J_mat @ J_mat
    # On e0, e1
    results.append(TR(
        f"J²_e0e1={abs(J_sq[0,0]):.2e}=0",
        abs(J_sq[0, 0]) < 1e-14 and abs(J_sq[1, 1]) < 1e-14,
    ))
    # On e2,...,e7
    diag_vals = [J_sq[i, i] for i in range(2, 8)]
    expected = -1.0 / 3.0
    max_err = max(abs(v - expected) for v in diag_vals)
    results.append(TR(
        f"J²_quarks={diag_vals[0]:.6f}=-1/3_err={max_err:.2e}",
        max_err < 1e-14,
    ))

    assert_all_pass(results)


# ---------------------------------------------------------------------------
# Test 49: u(4) center Y_c commutes with all gauge generators
# ---------------------------------------------------------------------------


def test_u4_center(so8: SO8) -> None:
    """Y_c = center of u(4) is the unique element commuting with all gauge gens.

    Prove: centralizer of su(3)∪su(2)∪u(1) in so(8) is 1-dimensional.
    Prove: Y_c commutes with all 12 gauge generators.
    Verify: Y_c matches bld.u4_center().
    Verify: Y_c is inside the gauge subspace (not in complement).
    """
    results: list[TR] = []
    dim = 28

    # Build centralizer system for ALL gauge generators
    rows: list[np.ndarray] = []
    for g_idx in range(12):
        for m in range(dim):
            row = np.zeros(dim)
            for k in range(dim):
                for j in range(dim):
                    row[k] += so8.gauge[g_idx, j] * so8.f[k, j, m]
            rows.append(row)

    A = np.array(rows)
    rank_A = int(la.matrix_rank(A, tol=1e-10))
    cent_dim = dim - rank_A
    results.append(TR(f"centralizer_all_gauge_dim={cent_dim}=1", cent_dim == 1))

    # Y_c from bld
    Yc = tools.bld.u4_center()

    # Verify commutes with all gauge generators
    max_comm = 0.0
    for g_idx in range(12):
        bracket = tools.bld.lie_bracket(Yc, so8.gauge[g_idx], so8.f)
        n = float(la.norm(bracket))
        if n > max_comm:
            max_comm = n
    results.append(TR(f"Yc_commutes_all={max_comm:.2e}", max_comm < 1e-12))

    # Y_c is inside gauge subspace
    Q_gauge, _ = la.qr(so8.gauge.T, mode="reduced")
    proj_gauge = Q_gauge @ Q_gauge.T
    residual = float(la.norm(Yc - proj_gauge @ Yc))
    results.append(TR(
        f"Yc_in_gauge_space_res={residual:.2e}",
        residual < 1e-12,
    ))

    # Y_c eigenvalues on 8_v: all ±1/2
    Yc_mat = tools.bld.coeff_to_matrix(Yc, so8.basis)
    Yc_sq = Yc_mat @ Yc_mat
    Yc_sq_eigs = la.eigvalsh(Yc_sq)
    expected_sq = -0.25  # -(1/2)² = -1/4
    max_err = float(max(abs(e - expected_sq) for e in Yc_sq_eigs))
    results.append(TR(
        f"Yc_sq_eigs_uniform_err={max_err:.2e}",
        max_err < 1e-12,
    ))

    assert_all_pass(results)


# ---------------------------------------------------------------------------
# Test 50: SM hypercharge eigenvalue ratio = 3
# ---------------------------------------------------------------------------


def test_hypercharge_ratio(so8: SO8) -> None:
    """The lepton-to-quark charge magnitude ratio is exactly 3.

    Prove: |Y(lepton)| / |Y(quark)| = 3 from Y_{B-L} eigenvalues.
    Prove: this ratio is independent of normalization choice.
    Verify: Y_{B-L} = bld.hypercharge_bl() has unit norm.
    Disprove: E₀₁ alone gives ratio ∞ (quarks have Y=0).
    """
    results: list[TR] = []

    Y_BL = tools.bld.hypercharge_bl()
    results.append(TR(
        f"Y_BL_norm={la.norm(Y_BL):.6f}=1",
        abs(la.norm(Y_BL) - 1.0) < 1e-12,
    ))

    # Eigenvalues via Y_BL²
    Y_BL_mat = tools.bld.coeff_to_matrix(Y_BL, so8.basis)
    Y_BL_sq = Y_BL_mat @ Y_BL_mat
    eigs_sq = la.eigvalsh(Y_BL_sq)
    charges_sq = -np.sort(eigs_sq)[::-1]  # -Y² → positive charge²

    # Two distinct charge magnitudes
    charge_vals = sorted(set(round(float(c), 6) for c in charges_sq))
    results.append(TR(
        f"n_distinct_charges={len(charge_vals)}=2",
        len(charge_vals) == 2,
    ))

    # Lepton charge² = 3/4, quark charge² = 1/12
    lepton_sq = max(charges_sq)
    quark_sq = min(charges_sq[charges_sq > 1e-10])
    results.append(TR(
        f"lepton_q²={float(lepton_sq):.6f}=3/4",
        abs(float(lepton_sq) - 0.75) < 1e-10,
    ))
    results.append(TR(
        f"quark_q²={float(quark_sq):.6f}=1/12",
        abs(float(quark_sq) - 1.0 / 12.0) < 1e-10,
    ))

    # Ratio of charge magnitudes
    ratio = math.sqrt(float(lepton_sq) / float(quark_sq))
    results.append(TR(f"ratio={ratio:.6f}=3", abs(ratio - 3.0) < 1e-10))

    # Multiplicities: 2 leptons, 6 quarks
    n_lepton = int(np.sum(charges_sq > 0.5))
    n_quark = int(np.sum((charges_sq > 0.01) & (charges_sq < 0.5)))
    results.append(TR(
        f"multiplicities=({n_lepton},{n_quark})=(2,6)",
        n_lepton == 2 and n_quark == 6,
    ))

    # Disprove: E01 alone gives quarks Y=0 (ratio undefined)
    E01_mat = tools.bld.coeff_to_matrix(so8.u1, so8.basis)
    E01_sq = E01_mat @ E01_mat
    e01_eigs = la.eigvalsh(E01_sq)
    n_zero_e01 = int(np.sum(np.abs(e01_eigs) < 1e-10))
    results.append(TR(
        f"E01_zero_quarks={n_zero_e01}=6",
        n_zero_e01 == 6,
    ))

    assert_all_pass(results)


# ---------------------------------------------------------------------------
# Test 51: SM hypercharge normalization on 8_v and 8_s
# ---------------------------------------------------------------------------


def test_hypercharge_sm_normalization(so8: SO8) -> None:
    """Y_SM gives |Y|=1/2 for leptons and |Y|=1/6 for quarks on 8_v, 8_s.

    Prove: |Y_SM(lepton)| = 1/2 on 8_v.
    Prove: |Y_SM(quark)| = 1/6 on 8_v.
    Prove: same pattern on 8_s.
    Verify: Y_SM = hypercharge_bl()/√3.
    """
    results: list[TR] = []

    Y_SM = tools.bld.hypercharge_sm()

    # Verify relation to Y_BL
    Y_BL = tools.bld.hypercharge_bl()
    diff = float(la.norm(Y_SM - Y_BL / math.sqrt(3)))
    results.append(TR(f"Y_SM=Y_BL/sqrt3_err={diff:.2e}", diff < 1e-14))

    # --- 8_v ---
    Y_SM_mat_v = tools.bld.coeff_to_matrix(Y_SM, so8.basis)
    Y_SM_sq_v = Y_SM_mat_v @ Y_SM_mat_v
    eigs_v = -la.eigvalsh(Y_SM_sq_v)  # charge² (positive)

    lepton_q = math.sqrt(float(max(eigs_v)))
    quark_q = math.sqrt(float(min(eigs_v[eigs_v > 1e-10])))
    results.append(TR(
        f"8v_lepton_|Y|={lepton_q:.6f}=1/2",
        abs(lepton_q - 0.5) < 1e-10,
    ))
    results.append(TR(
        f"8v_quark_|Y|={quark_q:.6f}=1/6",
        abs(quark_q - 1.0 / 6.0) < 1e-10,
    ))

    # --- 8_s ---
    gammas, chirality = tools.bld.clifford_gammas()
    rep_s, _ = tools.bld.spinor_reps_d4(gammas, chirality)
    Y_SM_mat_s = tools.bld.coeff_to_matrix(Y_SM, rep_s)
    Y_SM_sq_s = Y_SM_mat_s @ Y_SM_mat_s
    eigs_s = -la.eigvalsh(Y_SM_sq_s)

    lepton_q_s = math.sqrt(float(max(eigs_s)))
    quark_q_s = math.sqrt(float(min(eigs_s[eigs_s > 1e-10])))
    results.append(TR(
        f"8s_lepton_|Y|={lepton_q_s:.6f}=1/2",
        abs(lepton_q_s - 0.5) < 1e-10,
    ))
    results.append(TR(
        f"8s_quark_|Y|={quark_q_s:.6f}=1/6",
        abs(quark_q_s - 1.0 / 6.0) < 1e-10,
    ))

    assert_all_pass(results)


# ---------------------------------------------------------------------------
# Test 52: 8_c has different hypercharge pattern (right-handed sector)
# ---------------------------------------------------------------------------


def test_hypercharge_8c_pattern(so8: SO8) -> None:
    """8_c has |Y|={1/3, 0} — distinct from the 8_v/8_s pattern.

    Prove: 8_c has 6 states with |Y|=1/3 and 2 states with |Y|=0.
    Prove: this is different from 8_v/8_s (which have {1/2, 1/6}).
    Verify: triality still holds for total charge: Σ|Y|² is same for all three.
    """
    results: list[TR] = []

    Y_SM = tools.bld.hypercharge_sm()
    gammas, chirality = tools.bld.clifford_gammas()
    _, rep_c = tools.bld.spinor_reps_d4(gammas, chirality)

    Y_SM_mat_c = tools.bld.coeff_to_matrix(Y_SM, rep_c)
    Y_SM_sq_c = Y_SM_mat_c @ Y_SM_mat_c
    eigs_c = -la.eigvalsh(Y_SM_sq_c)  # charge² (positive)

    # 6 states with |Y|=1/3 and 2 states with |Y|=0
    n_third = int(np.sum(np.abs(eigs_c - 1.0 / 9.0) < 1e-10))
    n_zero = int(np.sum(np.abs(eigs_c) < 1e-10))
    results.append(TR(f"8c_n_third={n_third}=6", n_third == 6))
    results.append(TR(f"8c_n_zero={n_zero}=2", n_zero == 2))

    # Different from 8_v/8_s
    Y_SM_mat_v = tools.bld.coeff_to_matrix(Y_SM, so8.basis)
    Y_SM_sq_v = Y_SM_mat_v @ Y_SM_mat_v
    eigs_v = -la.eigvalsh(Y_SM_sq_v)

    # 8_v has no states with |Y|=1/3
    n_third_v = int(np.sum(np.abs(eigs_v - 1.0 / 9.0) < 1e-10))
    results.append(TR(f"8v_n_third={n_third_v}=0", n_third_v == 0))

    # Triality check: Σ|Y|² (= -Tr(Y_SM²)) is the same for all three reps
    rep_s, _ = tools.bld.spinor_reps_d4(gammas, chirality)
    Y_SM_mat_s = tools.bld.coeff_to_matrix(Y_SM, rep_s)

    tr_v = -float(np.trace(Y_SM_mat_v @ Y_SM_mat_v))
    tr_s = -float(np.trace(Y_SM_mat_s @ Y_SM_mat_s))
    tr_c = -float(np.trace(Y_SM_mat_c @ Y_SM_mat_c))
    results.append(TR(
        f"TrY²_v={tr_v:.6f}_s={tr_s:.6f}_c={tr_c:.6f}",
        abs(tr_v - tr_s) < 1e-10 and abs(tr_v - tr_c) < 1e-10,
    ))

    assert_all_pass(results)


# ---------------------------------------------------------------------------
# Test 53: No su(2) commutes with su(3) in so(8)
# ---------------------------------------------------------------------------


def test_no_su2_commutes_with_su3(so8: SO8) -> None:
    """The centralizer of su(3) in so(8) is 2-dim and abelian.

    Prove: centralizer dimension = 2 = bld.centralizer_su3_dim().
    Prove: [E₀₁, J] = 0 (abelian centralizer).
    Prove: no non-abelian subalgebra commutes with su(3).
    Verify: the two centralizer generators are E₀₁ and J.
    Disprove: removing one su(3) generator opens the centralizer to dim > 2.
    """
    results: list[TR] = []
    dim = 28

    # Build centralizer system [X, T_a] = 0 for all su(3) gens
    rows: list[np.ndarray] = []
    for a in range(8):
        for m in range(dim):
            row = np.zeros(dim)
            for k in range(dim):
                for j in range(dim):
                    row[k] += so8.su3[a, j] * so8.f[k, j, m]
            rows.append(row)

    A = np.array(rows)
    rank_A = int(la.matrix_rank(A, tol=1e-10))
    cent_dim = dim - rank_A
    results.append(TR(f"centralizer_su3_dim={cent_dim}=2", cent_dim == 2))

    # Matches bld constant
    results.append(TR(
        f"bld_centralizer_dim={tools.bld.centralizer_su3_dim()}=2",
        tools.bld.centralizer_su3_dim() == 2,
    ))

    # [E₀₁, J] = 0 (abelian)
    J = tools.bld.complex_structure_j()
    bracket_EJ = tools.bld.lie_bracket(so8.u1, J, so8.f)
    results.append(TR(
        f"[E01,J]_norm={la.norm(bracket_EJ):.2e}=0",
        la.norm(bracket_EJ) < 1e-14,
    ))

    # No non-abelian subalgebra: dim < 3, so no su(2) fits
    results.append(TR(
        "no_su2_in_centralizer_dim_too_small",
        cent_dim < 3,
    ))

    # Disprove: su(2) (3-dim, smaller subalgebra) has much larger centralizer
    rows_su2: list[np.ndarray] = []
    for a in range(3):
        for m in range(dim):
            row = np.zeros(dim)
            for k in range(dim):
                for j in range(dim):
                    row[k] += so8.su2[a, j] * so8.f[k, j, m]
            rows_su2.append(row)
    A_su2 = np.array(rows_su2)
    cent_dim_su2 = dim - int(la.matrix_rank(A_su2, tol=1e-10))
    results.append(TR(
        f"su2_centralizer_dim={cent_dim_su2}>2",
        cent_dim_su2 > cent_dim,
    ))

    assert_all_pass(results)


# ---------------------------------------------------------------------------
# Test 54: e_R found in 35_v = S²(8_v) with |Y| = 1
# ---------------------------------------------------------------------------


def test_eR_in_35v(so8: SO8) -> None:
    """The right-handed electron lives in S²(8_v) with |Y_SM| = 1.

    Prove: S²(8_v) contains exactly 2 states with |Y| = 1.
    Prove: these states are su(3) singlets (C₂(su3) = 0).
    Prove: |Y| = 1 comes from lepton ⊗ lepton (Y = 1/2 + 1/2).
    Verify: 35_v (= S²(8_v) minus trace) retains both |Y|=1 states.
    Disprove: adjoint (28) and ∧³(8_v) (56) do NOT contain |Y|=1.
    """
    results: list[TR] = []

    Y_SM = tools.bld.hypercharge_sm()

    # Y_SM eigenvalues on 8_v
    Y_mat = tools.bld.coeff_to_matrix(Y_SM, so8.basis)
    eigs_Y = np.sort(la.eigvals(Y_mat).imag)

    # S²(8_v) representation of Y_SM
    Y_S2 = tools.bld.sym2_rep(np.array([Y_mat]))[0]
    Y_S2_sq = Y_S2 @ Y_S2
    eigs_S2 = la.eigvalsh(Y_S2_sq)

    # Count |Y|=1 states (Y² = -1)
    n_Y1 = int(np.sum(np.abs(eigs_S2 + 1.0) < 1e-8))
    results.append(TR(f"S2_8v_n_Y1={n_Y1}=2", n_Y1 == 2))

    # su(3) Casimir on S²(8_v)
    su3_S2 = tools.bld.sym2_rep(
        np.array([tools.bld.coeff_to_matrix(g, so8.basis) for g in so8.su3])
    )
    C2_su3_S2 = sum(su3_S2[a] @ su3_S2[a] for a in range(8))

    # Diagonalize both simultaneously
    A_comb = C2_su3_S2 + math.sqrt(2) * Y_S2_sq
    _, V = la.eigh(A_comb)
    c2_diag = np.diag(V.T @ C2_su3_S2 @ V)
    y2_diag = np.diag(V.T @ Y_S2_sq @ V)

    # |Y|=1 states are su(3) singlets
    y1_mask = np.abs(y2_diag + 1.0) < 1e-6
    c2_at_y1 = c2_diag[y1_mask]
    results.append(TR(
        f"Y1_states_are_su3_singlets",
        all(abs(c) < 1e-8 for c in c2_at_y1),
    ))

    # Verify: trace has Y=0, so |Y|=1 states survive in 35_v
    dim_S2 = Y_S2.shape[0]
    d = 8
    pairs = [(i, j) for i in range(d) for j in range(i, d)]
    trace_vec = np.zeros(dim_S2)
    for i in range(d):
        trace_vec[pairs.index((i, i))] = 1.0
    trace_vec = trace_vec / la.norm(trace_vec)
    trace_Y2 = trace_vec @ Y_S2_sq @ trace_vec
    results.append(TR(
        f"trace_Y2={trace_Y2:.6f}=0",
        abs(trace_Y2) < 1e-12,
    ))

    # |Y|=1 from lepton ⊗ lepton: max(eigs_Y) = 1/2, so 1/2 + 1/2 = 1
    max_Y = float(max(eigs_Y))
    results.append(TR(
        f"max_Y_8v={max_Y:.4f}=1/2",
        abs(max_Y - 0.5) < 1e-10,
    ))
    results.append(TR(
        "lepton_x_lepton_gives_1",
        abs(2 * max_Y - 1.0) < 1e-10,
    ))

    # Disprove: adjoint (28) has no |Y|=1
    Y_adj = np.zeros((28, 28))
    for a in range(28):
        bracket = tools.bld.lie_bracket(Y_SM, np.eye(28)[a], so8.f)
        Y_adj[:, a] = bracket
    eigs_adj = la.eigvalsh(Y_adj @ Y_adj)
    n_Y1_adj = int(np.sum(np.abs(eigs_adj + 1.0) < 1e-8))
    results.append(TR(f"adjoint_n_Y1={n_Y1_adj}=0", n_Y1_adj == 0))

    # Disprove: ∧³(8_v) has no |Y|=1
    # max|y_i+y_j+y_k| = 1/2+1/6+1/6 = 5/6 < 1
    max_wedge3_Y = float(eigs_Y[-1] + eigs_Y[-2] + eigs_Y[-3])
    results.append(TR(
        f"max_wedge3_Y={max_wedge3_Y:.4f}<1",
        max_wedge3_Y < 1.0 - 1e-10,
    ))

    assert_all_pass(results)


# ---------------------------------------------------------------------------
# Test 55: 35_v charge decomposition under su(3) × Y_SM
# ---------------------------------------------------------------------------


def test_35v_charge_decomposition(so8: SO8) -> None:
    """S²(8_v) decomposes into specific su(3) × u(1) multiplets.

    Prove: S²(8_v) = (1,|Y|=1)₂ ⊕ (3,|Y|=2/3)₆ ⊕ (3,|Y|=1/3)₆
                      ⊕ (6,|Y|=1/3)₁₂ ⊕ (8,|Y|=0)₈ ⊕ (1,|Y|=0)₂.
    Verify: total = 36 = dim S²(8_v).
    Verify: removing trace (1 state at |Y|=0) gives 35_v.
    """
    results: list[TR] = []

    Y_SM = tools.bld.hypercharge_sm()
    Y_mat = tools.bld.coeff_to_matrix(Y_SM, so8.basis)

    # Build S²(8_v) Casimirs
    su3_S2 = tools.bld.sym2_rep(
        np.array([tools.bld.coeff_to_matrix(g, so8.basis) for g in so8.su3])
    )
    Y_S2 = tools.bld.sym2_rep(np.array([Y_mat]))[0]
    C2_su3_S2 = sum(su3_S2[a] @ su3_S2[a] for a in range(8))
    Y_S2_sq = Y_S2 @ Y_S2

    # Diagonalize
    A_comb = C2_su3_S2 + math.sqrt(2) * Y_S2_sq
    _, V = la.eigh(A_comb)
    c2_diag = np.diag(V.T @ C2_su3_S2 @ V)
    y2_diag = np.diag(V.T @ Y_S2_sq @ V)

    # Cluster by (C2_su3, |Y|)
    y_mag = np.sqrt(np.abs(y2_diag))
    qn = np.column_stack([c2_diag, y_mag])
    multiplets = tools.bld.cluster_multiplets(qn, tol=0.01)

    # Expected: (C2, |Y|) -> count
    # C2(1)=0, C2(3)=-4/3, C2(6)=-10/3, C2(8)=-3
    expected = {
        (0.0, 1.0): 2,
        (-1.3333, 0.6667): 6,
        (-1.3333, 0.3333): 6,
        (-3.3333, 0.3333): 12,
        (-3.0, 0.0): 8,
        (0.0, 0.0): 2,
    }

    for (c2_exp, y_exp), n_exp in expected.items():
        found = False
        for key, indices in multiplets.items():
            if abs(key[0] - c2_exp) < 0.05 and abs(key[1] - y_exp) < 0.05:
                results.append(TR(
                    f"C2={c2_exp:.1f}_Y={y_exp:.4f}_n={len(indices)}={n_exp}",
                    len(indices) == n_exp,
                ))
                found = True
                break
        if not found:
            results.append(TR(
                f"C2={c2_exp:.1f}_Y={y_exp:.4f}_MISSING",
                False,
            ))

    # Total count
    total = sum(len(v) for v in multiplets.values())
    results.append(TR(f"total={total}=36", total == 36))

    assert_all_pass(results)


# ---------------------------------------------------------------------------
# Test 56: Triality distinguishes 35_v/35_s (have e_R) from 35_c (no e_R)
# ---------------------------------------------------------------------------


def test_eR_triality_asymmetry(so8: SO8) -> None:
    """35_v and 35_s contain |Y|=1 but 35_c does not.

    Prove: 35_v has 2 states with |Y|=1.
    Prove: 35_s has 2 states with |Y|=1.
    Prove: 35_c has 0 states with |Y|=1.
    Verify: max |Y| in 35_c = 2/3.
    """
    results: list[TR] = []

    Y_SM = tools.bld.hypercharge_sm()
    gammas, chirality = tools.bld.clifford_gammas()
    rep_s, rep_c = tools.bld.spinor_reps_d4(gammas, chirality)

    for name, rep, expect_Y1 in [
        ("35_v", so8.basis, 2),
        ("35_s", rep_s, 2),
        ("35_c", rep_c, 0),
    ]:
        Y_rep = tools.bld.coeff_to_matrix(Y_SM, rep)
        eigs_Y = np.sort(la.eigvals(Y_rep).imag)

        # S²(rep) eigenvalues = y_i + y_j for i ≤ j
        n_Y1 = 0
        max_absY = 0.0
        for i in range(8):
            for j in range(i, 8):
                y_sum = abs(eigs_Y[i] + eigs_Y[j])
                if y_sum > max_absY:
                    max_absY = y_sum
                if abs(y_sum - 1.0) < 1e-8:
                    n_Y1 += 1

        results.append(TR(
            f"{name}_n_Y1={n_Y1}={expect_Y1}",
            n_Y1 == expect_Y1,
        ))

        if expect_Y1 == 0:
            results.append(TR(
                f"{name}_max_Y={max_absY:.4f}=2/3",
                abs(max_absY - 2.0 / 3.0) < 1e-8,
            ))

    assert_all_pass(results)
